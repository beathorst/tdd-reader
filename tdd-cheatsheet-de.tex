\documentclass[a4paper,10pt,headsepline]{scrartcl}
\include{packages}
\include{styles}

\usepackage[ngerman,american]{babel}
\selectlanguage{ngerman}

\hypersetup{
 pdfauthor={Oliver Klee, typo3-coding@oliverklee.de},
 pdftitle={Testgetriebene Entwicklung mit PHPUnit (mit oder ohne TYPO3)},
 pdfsubject={Handout zu Oliver Klees Workshops zu testgetriebener Entwicklung mit PHPUnit (mit oder ohne TYPO3).},
 pdfkeywords={TDD, unit testing, PHPUnit, workshop, seminar, PHP}
}

\author{
  Oliver Klee | \texttt{typo3-coding@oliverklee.de} | \texttt{@oliklee} \\
  \url{https://github.com/oliverklee/tdd-reader}
}

\date{Version 2.0.2, \today, für PHP >= 5.6 und TYPO3 CMS 7.6}

\title{
  Spickzettel zu testgetriebener Entwicklung mit PHPUnit
}

\begin{document}

\maketitle

\section*{Lizenz}

Dieser Reader ist unter einer \emph{Creative-Commons}-Lizenz lizensiert, und zwar konkret unter der \emph{Namensnennung-Weitergabe unter gleichen Bedingungen~4.0 (CC BY-SA 4.0)}. Das bedeutet, dass ihr den Reader unter diesen Bedingungen für euch kostenlos verbreiten, bearbeiten und nutzen könnt (auch kommerziell):

\begin{description}
  \item[Namensnennung.] Ihr müsst den Namen des Autors (Oliver Klee) nennen. Wenn ihr dabei zusätzlich auch noch die Quelle\footnote{\url{https://github.com/oliverklee/tdd-reader}} nennt, wäre das nett. Und wenn ihr mir zusätzlich eine Freude machen möchtet, sagt mir per E-Mail Bescheid.
  \item[Weitergabe unter gleichen Bedingungen.] Wenn ihr diesen Inhalt bearbeitet oder in anderer Weise umgestaltet, verändert oder als Grundlage für einen anderen Inhalt verwendet, dann dürft ihr den neu entstandenen Inhalt nur unter Verwendung identischer Lizenzbedingungen weitergeben.
  \item[Lizenz nennen.] Wenn ihr den Reader weiter verbreitet, müsst ihr dabei auch die Lizenzbedingungen nennen oder beifügen.
\end{description}

Die ausführliche Version dieser Lizenz findet ihr online.\footnote{\url{http://creativecommons.org/licenses/by-sa/4.0/}}


\pagebreak

\tableofcontents

\pagebreak

\section{Benennung von Dateien und Klassen}

\subsection{Dateinamen}

\begin{tabular}{|l|l|}
  \hline
  \fett{Dateiname des Produktionscodes} & \fett{Name der Testdatei} \\
  \hline
  \texttt{Classes/Domain/Model/Shoe.php} & \texttt{Tests/Unit/Domain/Model/ShoeTest.php} \\
  \hline
  \texttt{Classes/Service/BaristaService.php} & \texttt{Tests/Unit/Service/BaristaServiceTest.php} \\
  \hline
\end{tabular}


\subsection{Klassennamen}

\small
\begin{tabular}{|l|l|}
  \hline
  \fett{Name der Klasse im Produktionscode} & \fett{Name der Testklasse} \\
  \hline
  \texttt{Shoes\textbackslash Shop\textbackslash Domain\textbackslash Model\textbackslash Shoe} & \texttt{Shoes\textbackslash Shop\textbackslash Tests\textbackslash Unit\textbackslash Domain\textbackslash Model\textbackslash ShoeTest} \\
  \hline
  \texttt{Shoes\textbackslash Shop\textbackslash Service\textbackslash BaristaService} & \texttt{Shoes\textbackslash Shop\textbackslash Tests\textbackslash Unit\textbackslash Service\textbackslash BaristaServiceTest} \\
  \hline
\end{tabular}
\normalsize

\pagebreak
\section{Struktur von Testklassen}

\subsection{Extbase-Extensions}

Es gibt auf GitHub dazu auch ein Beispielprojekt (das \emph{Tea-Example}):\\
\url{https://github.com/oliverklee/ext_tea}\\

\begin{phpcode}
namespace \OliverKlee\Shop\Tests\Unit\Domain\Model;

use OliverKlee\Shop\Domain\Model\Article;

class ArticleTest extends \TYPO3\CMS\Core\Tests\UnitTestCase {
    /**
     * @var Article;
     */
    protected $subject = null;

    protected function setUp()
    {
        $this->subject = new Article;
        $this->subject->initializeObject();
    }

    /**
     * @test
     */
    public function getNameInitiallyReturnsEmptyString()
    {
        self::assertSame('', $this->subject->getName());
    }

    /**
     * @test
     */
    public function setNameSetsName()
    {
        $name = 'foo bar';

        $this->subject->setName($name);

        self::assertSame($name, $this->subject->getName());
    }

    // ...
}
\end{phpcode}

\subsection{Nicht-Extbase-Extensions}

\begin{phpcode}
class AttachmentTest extends \Tx_Phpunit_TestCase {
    /**
     * @var \Tx_Oelib_Attachment
     */
    protected $subject = null;

    protected function setUp()
    {
        $this->subject = new \Tx_Oelib_Attachment();
    }

    /**
     * @test
     */
    public function getFileNameInitiallyReturnsAnEmptyString()
    {
        self::assertSame('', $this->subject->getFileName());
    }

    /**
     * @test
     */
    public function getFileNameWithFileNameSetReturnsFileName()
    {
        $fileName = 'test.txt';

        $this->subject->setFileName($fileName);

        self::assertSame($fileName, $this->subject->getFileName());
    }

    /**
     * @test
     * @expectedException \InvalidArgumentException
     */
    public function setFileNameWithEmptyFileNameThrowsException()
    {
        $this->subject->setFileName('');
    }

    // ...
}
\end{phpcode}

\subsection{Nicht-TYPO3-PHP-Project mit Composer}

Es gibt auf GitHub dazu auch ein leeres Startprojekt:\\
\url{https://github.com/oliverklee/tdd-seed}

\subsubsection{composer.json}

Diese composer.json installiert PHPUnit und vfsStream für \fett{PHP bis 5.6}:\\

\begin{jsoncode}
{
    "require-dev": {
        "phpunit/phpunit": "^5.7.19",
        "mikey179/vfsStream": "^1.6.4"
    },
    "autoload": {
        "psr-4": {
            "..."
        }
    },
    "autoload-dev": {
        "psr-4": {
            "..."
        }
    }
}
\end{jsoncode}

Diese composer.json installiert PHPUnit und vfsStream für \fett{PHP ab 6}:\\

\begin{jsoncode}
{
    "require-dev": {
        "phpunit/phpunit": "^6.0.13",
        "mikey179/vfsStream": "^1.6.4"
    },
    "autoload": {
        "psr-4": {
            "..."
        }
    },
    "autoload-dev": {
        "psr-4": {
            "..."
        }
    }
}
\end{jsoncode}

\subsubsection{Testcase}
\begin{phpcode}
namespace OliverKlee\Books\Tests\Unit\Domain\Model;

use OliverKlee\Books\Domain\Model;

class BookTest extends \PHPUnit_Framework_TestCase {
    /**
     * @var Book
     */
    protected $subject = null;

    protected function setUp()
    {
        $this->subject = new Book();
    }

    /**
     * @test
     */
    public function getTitleInitiallyReturnsEmptyString()
    {
        self::assertSame('', $this->subject->getTitle());
    }

    /**
     * @test
     */
    public function setTitleSetsTitle()
    {
        $title = 'foo bar';

        $this->subject->setTitle($title);

        self::assertSame($title, $this->subject->getTitle());
    }
}
\end{phpcode}


\section{Mocks}

\subsection{Warum mocken?}
\begin{itemize}
  \item um eine Methode \glqq auszuschalten\grqq\ (damit sie nicht in die DB schreibt, kein Cruise-Missile abschießt etc.) und \texttt{null} zurückzugeben
  \item um einer Methode einen bestimmten Rückgabewert zu geben oder sie eine Exception werfen zu lassen
  \item um zu testen, dass eine Methode auf eine bestimmte Art und Weise aufgerufen wird
\end{itemize}

\subsection{Tools für Mocks}

\paragraph{Prophecy:} Das empfohlene, einfach benutzbare, aktuelle Mocking-Framework. Allerdings kann es keine partiellen Mocks erzeugen.\footnote{Prophecy-Cheatsheet:\\ \url{https://github.com/oliverklee/tdd-reader/blob/master/AdditionalDocuments/prophecy-cheatsheet.pdf}}
\paragraph{PHPUnit mocks:} Die alte Art, Mocks zu erzeugen. Mocking ist damit etwas unhandlich, aber dafür kann es auch partielle Mocks erzeugen.\footnote{PHPUnit-Mocking-Cheatsheet:\\ \url{https://github.com/oliverklee/tdd-reader/blob/master/AdditionalDocuments/mocking-cheatsheet.pdf}}
\paragraph{Mockery:} Auch sehr elegant.\footnote{\url{https://github.com/mockery/mockery}}



\pagebreak
\section{Auf Exceptions testen}

\subsection{Nur auf die Klasse testen}
\begin{phpcode}
/**
 * @test
 * @expectedException InvalidArgumentException
 */
public function createBreadWithNegativeSizeThrowsException()
{
    $this->subject->createBread(-1);
}
\end{phpcode}

\subsection{Auf Klasse, Nachricht und Code testen}
\begin{phpcode}
/**
 * @test
 * @expectedException \InvalidArgumentException
 * @expectedExceptionMessage size must be > 0.
 * @expectedExceptionCode 1323700434
 */
public function createBreadWithNegativeSizeThrowsException()
{
    $this->subject->createBread(-1);
}
\end{phpcode}


\pagebreak
\section{Abstrakte Klassen testen}

\subsection{Den PHPUnit-Mock-Builder benutzen}

Dies erzeugt eine Instanz der abstrakten Klassen, wobei alle abstrakten Methoden gemockt werden.\\

\begin{phpcode}
namespace OliverKlee\Coffee\Tests\Unit\Domain\Model;

use OliverKlee\Coffee\Domain\Model\AbstractBeverage;

class AbstractBeverageTest {
    /**
     * @var AbstractBeverage|\PHPUnit_Framework_MockObject_MockObject
     */
    protected $subject = null;

    protected function setUp()
    {
        $this->subject = $this->getMockForAbstractClass(
            AbstractBeverage::class
        );
    }
\end{phpcode}

\subsection{Eine konkrete Unterklasse erstellen}

Dies wird empfohlen, wenn die Subklasse zusätzliches oder spezifisches Verhalten haben soll.

Erzeugt in \texttt{Tests/Unit/Unit/Domain/Model/Fixtures/} eine Unterklasse der abstrakten Klasse:\\

\begin{phpcode}
namespace OliverKlee\Coffee\Tests\Unit\Domain\Model\Fixtures;

class TestingBeverage extends \OliverKlee\Coffee\Domain\Model\AbstractBeverage {
    // ...
}
\end{phpcode}

Dann könnt ihr die konkrete Unterklasse in euren Unit-Tests usen und instanziieren.\\

\begin{phpcode}
use OliverKlee\Coffee\Tests\Unit\Domain\Model\Fixtures\TestingBeverage;

class AbstractBeverageTest {
    /**
     * @var TestingBeverage
     *
    protected $subject = null;

    protected function setUp()
    {
        $this->subject = new TestingBeverage();
    }
\end{phpcode}


\pagebreak
\section{Das Test-Framework der PHPUnit-TYPO3-Extension benutzen}

\begin{phpcode}
class DataMapperTest extends \Tx_Phpunit_TestCase {
    /**
     * @var \Tx_Phpunit_Framework
     */
    protected $testingFramework = null;

    protected $subject = null;

    protected function setUp()
    {
        $this->testingFramework = new \Tx_Phpunit_Framework('tx_oelib');

        $this->subject = new ...;
    }

    protected function tearDown()
    {
        $this->testingFramework->cleanUp();
    }

    /**
     * @test
     */
    public function findWithUidOfExistingRecordReturnsModelDataFromDatabase()
    {
        $title = 'foo';
        $uid = $this->testingFramework->createRecord(
            'tx_oelib_test', ['title' => $title]
        );

        self::assertSame($title, $this->subject->find($uid)->getTitle());
    }
\end{phpcode}

\pagebreak
\section{Gemockte Dateisystem mit vfsStream benutzen}

\subsection{Lauffähige Beispiele}

Die funktionalen Tests zur FileUtility-Klasse im Tea-Beispiel zeigen, wie Tests mit vfsStream aussehen können.


\subsection{Einrichten}
\begin{phpcode}
use org\bovigo\vfs\vfsStream;
use org\bovigo\vfs\vfsStreamDirectory;

/**
 * @var \org\bovigo\vfs\vfsStreamFile
 */
protected $moreStuff;

protected function setUp()
{
    // This is the same as ::register and ::setRoot.
    $this->root = vfsStream::setup('home');
    $this->targetFilePath = vfsStream::url('home/target.txt');

    $this->subject = new ...
}
\end{phpcode}

\subsection{Die Dateien benutzen}
\small
\begin{phpcode}
/**
 * @test
 */
public function concatenateWithOneEmptySourceFileCreatesEmptyTargetFile()
{
    // This is one way to create a file with contents, using PHP's file functions.
    $sourceFileName = vfsStream::url('home/source.txt');
    // Just calling vfsStream::url does not create the file yet.
    // We need to write into it to create it.
    file_put_contents($sourceFileName, '');

    $this->subject->concatenate($this->targetFilePath, [$sourceFileName]);

    self::assertSame('', file_get_contents($this->targetFilePath));
}

/**
 * @test
 */
public function concatenateWithOneFileCopiesContentsFromSourceFileToTargetFile()
{
    // This is vfsStream's way of creating a file with contents.
    $contents = 'Hello world!';
    $sourceFileName = vfsStream::url('home/source.txt');
    vfsStream::newFile('source.txt')->at($this->root)->setContent($contents);

    $this->subject->concatenate($this->targetFilePath, [$sourceFileName]);

    self::assertSame($contents, file_get_contents($this->targetFilePath));
}
\end{phpcode}
\normalsize


\pagebreak
\section{PHPUnit-Assertions}
Diese Liste ist aktuell für PHPUnit 5.7.x.

\begin{verbatim}
assertArrayHasKey()
assertClassHasAttribute()
assertArraySubset()
assertClassHasStaticAttribute()
assertContains()
assertContainsOnly()
assertContainsOnlyInstancesOf()
assertCount()
assertDirectoryExists()
assertDirectoryIsReadable()
assertDirectoryIsWritable()
assertEmpty()
assertEqualXMLStructure()
assertEquals()
assertFalse()
assertFileEquals()
assertFileExists()
assertFileIsReadable()
assertFileIsWritable()
assertGreaterThan()
assertGreaterThanOrEqual()
assertInfinite()
assertInstanceOf()
assertInternalType()
assertIsReadable()
assertIsWritable()
assertJsonFileEqualsJsonFile()
assertJsonStringEqualsJsonFile()
assertJsonStringEqualsJsonString()
assertLessThan()
assertLessThanOrEqual()
assertNan()
assertNull()
assertObjectHasAttribute()
assertRegExp()
assertStringMatchesFormat()
assertStringMatchesFormatFile()
assertSame()
assertStringEndsWith()
assertStringEqualsFile()
assertStringStartsWith()
assertThat()
assertTrue()
assertXmlFileEqualsXmlFile()
assertXmlStringEqualsXmlFile()
assertXmlStringEqualsXmlString()
\end{verbatim}

\end{document}
